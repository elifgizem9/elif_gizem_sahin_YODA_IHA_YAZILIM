### ROS 
### ROS (Robot Operating System): 
İsminde işletim sistemi geçse de teknik olarak geleneksel bir işletim sistemi değildir. ROS, robotik yazılımlar geliştirmek için kullanılan bir ara katman yazılımıdır. İşletim sistemi ile kullanıcı yazılımları arasında durarak donanım soyutlaması, düşük seviyeli cihaz kontrolü, süreçler arası mesajlaşma ve paket yönetimi sağlar.
ROS, dağıtık bir mimariye sahiptir. Sistem, belirli görevleri yerine getiren bağımsız program parçacıklarından oluşur. Bu parçacıklar birbirleriyle iletişim kurarak karmaşık robotik davranışları ortaya çıkarır. Bu parçacıklara node denir.

### ROS'un Temel Bileşenleri

ROS ekosistemini oluşturan ve node ların etkileşime girmesini sağlayan temel yapılar şunlardır:

**Nodes:** ROS içindeki en temel işlem birimidir. Örneğin; bir node kameradan görüntü alırken, diğer bir node tekerlek motorlarını kontrol edebilir. Her node tek bir amaca hizmet etmelidir.
**Topics:** Nodeların veri alışverişi yaptığı kanallardır. Sürekli veri akışı için kullanılır (örneğin: sensör verisi, lidar taraması).
**Messages:** Topicler üzerinden gönderilen veri paketleridir (örneğin: Hız verisi, konum bilgisi).
**Publisher:** Belirli bir Topic'e veri gönderen Node'dur.
**Subscriber:** Belirli bir Topic'i dinleyen ve gelen veriyi işleyen Node'dur.
**Services:** Request-Response mantığıyla çalışır. Topiclerin aksine sürekli veri akışı değil, sadece çağrıldığında işlem yapıp sonuç döndürmek için kullanılır (örneğin: "Robotu kalibre et" komutu).
**Actions:** Servislere benzer ancak uzun süreli görevler için tasarlanmıştır. Görev devam ederken feedback sağlar ve görev iptal edilebilir (örneğin: "A noktasına git" komutu verilirken robot o sırada ne kadar yol gittiğini sürekli raporlar).
**Parameters (Parametreler):** Nodeların çalışma ayarlarını kod değişikliği yapmadan dışarıdan yapılandırmaya yarayan değerlerdir.

### ROS 1 ve ROS 2 Farkları

İletişim altyapısı farklıdır
ROS 1: TCPROS/UDPROS . Özel protokoldür
ROS 2: DDS yani Data Distribution Service . Endüstriyel standarttır. 

Merkeziyetleri farklıdır 
ROS 1: roscore yani Master Node zorunludur. Master çökerse sistem durur. 
ROS 2:Distributed. Master node yoktur, nodelar birbirini otomatik keşfeder.

Gerçek zamanlılık farklıdır 
ROS 1:Doğrudan desteklenmez.
ROS 2:Gerçek zamanlı sistemler için tasarlanmıştır.

İşletim sistemi farklıdır
ROS 1: Sadece Linux üzerinde tam verimli çalışır. 
ROS 2: Linux, Windows ve macOS üzerinde native olarak çalışır. 

Dil desteği farklıdır 
ROS 1: C++03 ve Python 2
ROS 2: Modern C++ ve Python 3

### Robotik Projelerinde Yaygın Kullanım Alanları
Otonom Mobil Robotlar: Depo lojistiği, temizlik robotları.
Endüstriyel Robot Kolları: Montaj hatları.
Otonom Sürüş: Araçların algılama, planlama ve kontrol mekanizmaları.
Tarım Robotları: Hasat toplama, ilaçlama otomasyonu.

### İHA Projelerindeki Rolü
ROS, İHA projelerinde yüksek seviyeli kontrol ve yapay zeka entegrasyonu için kritik bir rol oynar. Genellikle Mavros paketi kullanılarak uçuş kontrolcüsü ile yerleşik bilgisayar arasında köprü kurulur.
**SLAM:** İHA'nın kapalı alanda harita çıkarıp konumunu bulması.
**Görüntü İşleme:** Nesne takibi, otonom iniş.
**Sürü Yönetimi:** Birden fazla İHA'nın koordineli hareketi.


## Ubuntu Kurulum
Bu aşamada, bilgisayarımda mevcut olan Windows işletim sistemini koruyarak Ubuntu kurulumu gerçekleştirdim.

**Yapılan İşlemler:**
1. Disk Bölümlendirme: Windows Disk Yönetimi üzerinden D sürücüsü küçültülerek Ubuntu için 60 GB'lık ayrılmamış alan oluşturdum.
2. BIOS Ayarları: BIOS menüsünden Secure Boot u kapattım. USB önceliğini ayarladım.
3. Kurulum: Ubuntu 24.04 LTS sürümünü USB bellek ile başlattım. Kurulum türü olarak Windows Boot Manager yanına kur seçeneğini kullanarak veri kaybını önledim.
4. Sürücü ve Güncellemeler: Kurulum sonrası terminal üzerinden "sudo apt update && sudo apt upgrade" komutları ile sistem paketlerini güncelledim. Yazılım ve Güncellemeler aracı kullanarak NVIDIA ekran kartı için uygun sahipli sürücüleri aktif ettim.

## ROS2 Kurulumu
Bilgisayarıma kurulan Ubuntu sürümü 24.04 Noble Numbat olduğu için, bu sürümle uyumlu olan ROS2 Jazzy Jalisco versiyonunu tercih ettim. ROS2 Humble, Ubuntu 22.04 gerektirdiği için sürüm uyumsuzluğu yaşamamak için bu yolu izledim.

**Kurulum Adımları:**
1. Locale Ayarı: UTF-8 desteği "locale-gen" komutları ile sağlandı.
2. Kaynak Ekleme: ROS2 depoları ve GPG anahtarını sisteme ekledim.

sudo curl -sSL [https://raw.githubusercontent.com/ros/rosdistro/master/ros.key](https://raw.githubusercontent.com/ros/rosdistro/master/ros.key) -o /usr/share/keyrings/ros-archive-keyring.gpg

3. Paket Kurulumu: ROS2 Desktop paketi ve geliştirme araçlarını kurdum:

sudo apt install ros-jazzy-desktop ros-dev-tools

4. Ortam Tanımlama: Terminal her açıldığında ROS2 komutlarının çalışması için .bashrc dosyasına source eklendi:

echo "source /opt/ros/jazzy/setup.bash" >> ~/.bashrc
source ~/.bashrc


## ROS2 ve Turtlesim 
ROS2 mimarisini anlamak ve pratik yapmak amacıyla bir workspace oluşturdum ve turtlesim simülasyonu üzerinde çalışan bir node yazdım.

### Workspace ve Paket Oluşturma
Öncelikle ros2_ws adında bir dizin oluşturup derleme işlemi yaptım. Ardından Python tabanlı bir paket oluşturdum.

mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python my_turtle_controller --dependencies rclpy geometry_msgs

**Node Tasarımı**
Oluşturulan paketin içine, kaplumbağayı dairesel hareket ettiren turtle_mover.py kodu yazdım. Kod, Publisher yapısını kullanır.

"/turtle1/cmd_vel" e veri gönderir.

geometry_msgs/msg/Twist mesaj tipini kullanarak lineer (X ekseni) ve açısal (Z ekseni) hız verisi ürettim.

#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

class TurtleMover(Node):
    def __init__(self):
        super().__init__('turtle_mover_node')
        self.publisher_ = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)
        self.timer = self.create_timer(0.5, self.move_turtle)
        self.get_logger().info('Kaplumbaga Hareketi Baslatildi')

    def move_turtle(self):
        msg = Twist()
        msg.linear.x = 2.0  # İleri hız
        msg.angular.z = 1.0 # Dönme hızı
        self.publisher_.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = TurtleMover()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

**Test Sonuçları**
Kodu setup.py dosyasına tanıtıp colcon build ile derledikten sonra çalıştırdım. Bir terminalde turtlesim_node çalışırken, diğer terminalde yazdığım düğüm çalıştırıldı ve kaplumbağa, simülasyon ortamında dairesel hareket çizdi.